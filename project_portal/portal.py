from flask import Flask, render_template, request, redirect, url_for, session, jsonify
from flask_sqlalchemy import SQLAlchemy
from flask_mail import Mail, Message
import os
from datetime import datetime
from werkzeug.security import generate_password_hash, check_password_hash
from sqlalchemy.exc import IntegrityError
import csv
from sqlalchemy import func
import subprocess

# Initialize the Flask application
app = Flask(__name__)

# Secret key for session management (used for securing user sessions)
app.secret_key = 'your_secret_key'

# Database Configuration (Using SQLite as the database)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'  # SQLite database file
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False  # Disable modification tracking to improve performance
db = SQLAlchemy(app)  # Initialize SQLAlchemy for database management

# Email Configuration (For sending notifications after file upload)
app.config['MAIL_SERVER'] = 'smtp.gmail.com'  # SMTP server for sending emails
app.config['MAIL_PORT'] = 587  # SMTP port
app.config['MAIL_USE_TLS'] = True  # Use TLS for secure connection
app.config['MAIL_USERNAME'] = 'somaharsha71@gmail.com'  # Sender email
app.config['MAIL_PASSWORD'] = 'dtgp djyz ukup tmmv'  # App-specific password 
mail = Mail(app)  # Initialize Flask-Mail

# Models


# User Model for Database for Defining the structure of the user table
class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)  # Unique user ID 
    username = db.Column(db.String(50), unique=True, nullable=False)  # Unique username
    password = db.Column(db.String(255), nullable=False)  # Hashed password for security
    email = db.Column(db.String(100), unique=True, nullable=False)  # User's email 
    first_name = db.Column(db.String(50), nullable=False)  # User's first name
    last_name = db.Column(db.String(50), nullable=False)  # User's last name
    address = db.Column(db.String(255), nullable=False)  # User's address

# IoC Model for storing threat intelligence IOC data
class IoC(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    ioc_type = db.Column(db.String(50), nullable=True)    
    value = db.Column(db.String(256), nullable=True)        # The IOC value
    source = db.Column(db.String(100), nullable=True)      
    threat_category = db.Column(db.String(100), nullable=True)  # Threat category 
    date = db.Column(db.String(50), nullable=True)          # Date of the IOC record

# Create the database tables if they don't exist (Run only once)
with app.app_context():
    db.create_all()

# IOC Update Function

def update_ioc(csv_filepath='iocs_combined.csv'):
    """
    Reads the iocs_combined.csv file (generated by threat.py) and updates the IoC database table.
    The function clears the existing IoC data and loads new rows from the CSV.
    """
    if not os.path.exists(csv_filepath):
        print(f"CSV file '{csv_filepath}' not found.")
        return

    try:
        with open(csv_filepath, 'r', newline='', encoding='utf-8') as csvfile:
            reader = csv.DictReader(csvfile)
            ioc_rows = list(reader)
    except Exception as e:
        print(f"Error reading IOC CSV: {e}")
        return

    try:
        # Clear existing IoC records
        IoC.query.delete()
        db.session.commit()
    except Exception as e:
        db.session.rollback()
        print(f"Error clearing existing IoC records: {e}")

    try:
        for row in ioc_rows:
            new_ioc = IoC(
                ioc_type = row.get("Type"),
                value = row.get("Value"),
                source = row.get("Source"),
                threat_category = row.get("Threat_Category"),
                date = row.get("Date")
            )
            db.session.add(new_ioc)
        db.session.commit()
        print("IOC data updated successfully.")
    except Exception as e:
        db.session.rollback()
        print(f"Error updating IOC data: {e}")

# Routes


# Route for user login
@app.route('/', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        username = request.form['username']
        password = request.form['password']
        
        # Query the user from the database by username
        user = User.query.filter_by(username=username).first()
        
        # Check if user exists and password is correct
        if user and check_password_hash(user.password, password):
            session['username'] = username  # Store username in session
            
            
            subprocess.run(["python3", "threat.py"])
                        
            # Update IOC data from the new CSV file upon successful login
            update_ioc()
            return redirect(url_for('dashboard'))  # Redirect to dashboard after login
        else:
            return "Invalid Credentials", 401  # Return error message if login fails
    
    return render_template('login.html')  

# Route for user registration
@app.route('/register', methods=['GET', 'POST'])
def register():
    if request.method == 'POST':
        username = request.form['username']
        password = request.form['password']
        email = request.form['email']
        first_name = request.form['first_name']
        last_name = request.form['last_name']
        address = request.form['address']

        # Check if the username already exists in the database
        existing_user = User.query.filter_by(username=username).first()
        if existing_user:
            return "Username already exists!", 400  # Return an error if username is taken

        try:
            # Store the new user in the database
            new_user = User(
                username=username,
                password=generate_password_hash(password),  # Hash password before storing
                email=email,
                first_name=first_name,
                last_name=last_name,
                address=address
            )
            db.session.add(new_user)  # Add user to the session
            db.session.commit()  # Commit changes to the database

            return redirect(url_for('login'))  # Redirect to login page after registration
        except IntegrityError:
            db.session.rollback()  # Rollback the session if an IntegrityError occurs
            return "Email or username already exists!", 400  # Return specific error message

    return render_template('register.html')  # Render registration form

# Route for user dashboard (only accessible after login)
@app.route('/dashboard', methods=['GET', 'POST'])
def dashboard():
    if 'username' not in session:  # Check if user is logged in
        return redirect(url_for('login'))  # Redirect to login if not logged in

    # Get user details from the database
    user = User.query.filter_by(username=session['username']).first()
    if not user:
        return redirect(url_for('login'))  # Redirect if user doesn't exist

    # Get current server time
    current_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

    # Handle file upload (if any)
    if request.method == 'POST' and 'file' in request.files:
        file = request.files['file']
        if file.filename == '':  # Check if filename is empty
            return "No selected file", 400
        filepath = os.path.join('uploads', file.filename)  # Define the file save path
        file.save(filepath)  # Save the uploaded file
        send_email(user.email, filepath)  # Send email notification to user
        return "File uploaded and emailed successfully"

    # Retrieve IOC data for dashboard display
    # Allow search for IOC by keyword (search in the value field)
    ioc_keyword = request.args.get('ioc_keyword', '').strip()
    if ioc_keyword:
        ioc_query = IoC.query.filter(IoC.value.ilike(f'%{ioc_keyword}%'))
    else:
        ioc_query = IoC.query
    ioc_list = ioc_query.all()
    total_iocs = IoC.query.count()
    # Get count of each type of IOC
    types_count = db.session.query(IoC.ioc_type, func.count(IoC.id)).group_by(IoC.ioc_type).all()

    # Render dashboard with user details and IOC data
    return render_template('dashboard.html', 
                           username=user.username, 
                           user_details=user, 
                           current_time=current_time,
                           ioc_list=ioc_list,
                           total_iocs=total_iocs,
                           types_count=types_count,
                           ioc_keyword=ioc_keyword)

@app.route('/change_password', methods=['GET', 'POST'])
def change_password():
    if 'username' not in session:
        return redirect(url_for('login'))

    user = User.query.filter_by(username=session['username']).first()
    if not user:
        return redirect(url_for('login'))

    if request.method == 'POST':
        current_password = request.form['current_password']
        new_password = request.form['new_password']
        confirm_password = request.form['confirm_password']

        # Is current password correct?
        if not check_password_hash(user.password, current_password):
            return "Current password is incorrect", 400

        # Checking if new password and confirmation match
        if new_password != confirm_password:
            return "New passwords do not match", 400

        # Hashing the new password
        user.password = generate_password_hash(new_password)
        db.session.commit()
        return "Password changed successfully"

    return render_template('change_password.html')

# Function to send an email notification after file upload
def send_email(recipient, filepath):
    with app.app_context():
        msg = Message('File Upload Notification', sender=app.config['MAIL_USERNAME'], recipients=[recipient])
        msg.body = 'A file has been uploaded. See the attachment.'  # Email body
        
        # Attach the uploaded file to the email
        with open(filepath, 'rb') as f:
            msg.attach(os.path.basename(filepath), 'application/octet-stream', f.read())
        
        mail.send(msg)  # Send the email

# Main application entry point
if __name__ == '__main__':
    os.makedirs('uploads', exist_ok=True)  # Create 'uploads' directory if not exists
    app.run(host='0.0.0.0', port=8080, debug=True)  # Run the Flask app
